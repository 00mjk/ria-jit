% todo expand this section with further details

\begin{comment}
% ======= EXAMPLE PLOT =======
% Update, copy and modify as needed. Shows tikz usage.
% todo remove before submission (obviously).
% ============================
% The [h] requests TeX put the float <h>ere.
% There are other options for <p>age, <t>op, <b>ottom;
% If it shouldn't float, \usepackage{float} and use [H]
% or a minipage with associated caption.
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[%
			title = {Example bar graph},
			ybar,
			area legend,
			ylabel = {Value in some unit},
			xtick = data,
			xtick style = {draw = none},
			ytick = {0, 2500, 5000, 7500, 10000, 12500},
			scaled y ticks = false,
			symbolic x coords={First category, Second category, Third category},
			ymin = 0, ymax = 12500,
			ymajorgrids = true,
			height = 6.0cm,
			width = \linewidth,
			legend style = {
				at = {(0.5, -0.25)},
				anchor = north,
				legend columns = 3,
				column sep = 0.2cm
			}
		]	
			\addplot+ [
				fill=era-dbt-1,
				draw=black
			] coordinates {
				(First category, 3061)
				(Second category, 10930)
				(Third category, 10971)
			};
			
			\addplot+ [
				fill=era-qemu,
				draw=black
			] coordinates {
				(First category, 3061)
				(Second category, 9092)
				(Third category, 5042)
			};
			
			\addplot+ [
				fill=era-native,
				draw=black
			] coordinates {
				(First category, 4043)
				(Second category, 6092)
				(Third category, 7971)
			};

			
			\legend{First series, Second series, Third series}
		\end{axis}
	\end{tikzpicture}
	\caption{I am an example figure. If you're reading the submitted document, someone forgot to remove me.}
\end{figure}
\end{comment}


Measuring the performance of the DBT was accomplished by using the tools in \textit{SPEC CPU 2017}'s \texttt{intspeed} suite of benchmarks.
This not only generates reproducible and widely accepted results in the industry, it also validates the results produced during the run, thus ruling out any errors in the benchmark's translation.

% todo include benchmark description table (and list of tables) for the spec programs with the benchmark workload description
The \texttt{intspeed} suite also presents a variety of different workloads to the translator that are based on real-life scenarios, thus producing an accurate and understandable overview of the DBT's performance in a non-controlled environment.
Further context is provided by performance testing using the data compression utility \textit{gzip}~\cite{gzip}, where compression time is compared between runs on a native machine, in QEMU and in the DBT\@.

All testing was performed on an x86--64 8-core \textit{Intel Xeon Bronze 3106} system clocked at $1,70$ GHz base with $78$ GiB of physical memory, running \textit{Ubuntu 18.04.3 LTS}, kernel version \textit{4.15.0-70-generic}.
The DBT was compiled via \texttt{CMAKE\_BUILD\_TYPE} set to \texttt{Release} and \texttt{CMAKE\_INTERPROCEDURAL\_OPTIMIZATION} enabled, which implies \texttt{-O3} and \texttt{-flto -fno-fat-lto-objects}.

\subsection{SPEC CPU 2017 Results}
% todo benchmark results


% ======= SPEC CPU Results =======
% Results of the intspeed SPEC CPU 2017 runs.
% ================================
\pgfplotstableread[col sep=comma]{benchmarks/spec-base/native.csv}\nativetable
\pgfplotstableread[col sep=comma]{benchmarks/spec-base/dbt.csv}\dbttable
\pgfplotstablecreatecol[create col/copy column from table=\nativetable{Est. Base Run Time}]{native}\dbttable
\pgfplotstablecreatecol[create col/expr={\thisrow{Est. Base Run Time} / \thisrow{native}}]{ratio}\dbttable

\pgfplotstablesort[sort key = ratio, sort cmp=float >]\sorteddbttable{\dbttable}

%Extract xticklabels from file
\makeatletter
\pgfplotsset{
/pgfplots/flexible xticklabels from table/.code n args={2}{%
\pgfplotstablegetcolumn{#2}\of{#1}\to\pgfplots@xticklabels
\renewcommand{\pgfplots@xticklabel}\pgfplots@user@ticklabel@list@x
}
}
\makeatother
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[%
			title = {SPEC CPU 2017 \texttt{intspeed} Results},
			ybar,
			area legend,
			ylabel = {Execution time [ratio to native]},
			xtick = data,
			xtick style = {draw = none},
			xticklabel style = {
				inner sep = 0pt,
				anchor = north east,
				rotate = 60
			},
			ytick = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0},
			scaled y ticks = false,
			flexible xticklabels from table={\sorteddbttable}{Benchmark},
			ymin = 0, ymax = 6.5,
			ymajorgrids = true,
			bar width = 5pt,
			height = 7.0cm,
			width = 0.9\linewidth,
			legend style = {
				at = {(0.98, 0.97)},
				anchor = north east,
				legend columns = 3,
				column sep = 0.2cm
			}
		]
			% Native results
			\pgfplotstableread[col sep=comma]{benchmarks/spec-base/native.csv}\nativelocaltable
			\pgfplotstablecreatecol[create col/copy column from table=\nativetable{Est. Base Run Time}]{native}\nativelocaltable
			\pgfplotstablecreatecol[create col/expr={\thisrow{Est. Base Run Time} / \thisrow{native}}]{ratio}\nativelocaltable
			\pgfplotstablesort[sort key = ratio, sort key from ={\dbttable}, sort cmp=float >]\nativelocalsortedtable{\nativelocaltable}
			\addplot+[fill=era-native, draw=black] table [x expr=\coordindex, y=ratio] \nativelocalsortedtable;

			% QEMU results
			\pgfplotstableread[col sep=comma]{benchmarks/spec-base/qemu.csv}\qemutable
			\pgfplotstablecreatecol[create col/copy column from table=\nativetable{Est. Base Run Time}]{native}\qemutable
			\pgfplotstablecreatecol[create col/expr={\thisrow{Est. Base Run Time} / \thisrow{native}}]{ratio}\qemutable
			\pgfplotstablesort[sort key = ratio, sort key from ={\dbttable}, sort cmp=float >]\qemusortedtable{\qemutable}
			\addplot+[fill=era-qemu, draw=black] table [x expr=\coordindex, y=ratio] \qemusortedtable;

			% DBT results
			\addplot+[fill=era-dbt-1, draw=black] table [x expr=\coordindex, y=ratio] \sorteddbttable;

			\legend{Native, QEMU, DBT}
		\end{axis}
	\end{tikzpicture}
	\caption[SPEC CPU 2017 Results]%
	{Results of \texttt{ref}-workload runs of \textit{SPEC CPU 2017}'s \texttt{intspeed} (normalised, lower is better).}
	\label{fig:spec-results}
\end{figure}
% ================================

% todo analysis of SPEC runs



\subsection{Evaluation of translator optimisations}
\begin{table}
	\centering
	\begin{tabular}{rl}
		\toprule
		\textbf{Option} & \textbf{Description}\\
		\midrule
		\texttt{no-ras} & Disable the return address stack\\
		\texttt{no-chain} & Disable block chaining\\
		\texttt{no-jump} & Disable recursive jump target translation\\
		\texttt{no-fusion} & Disable macro operation fusion\\
		\texttt{none} & All of the above\\
		\bottomrule
	\end{tabular}
	% state: 5afb8706e482917866a3507a54d1512befe56a21
	\caption[Translator optimisation options]%
	{The options for translator optimisations, as seen in \texttt{----optimize=help}.}
	\label{tab:opt-options}
\end{table}

In order to evaluate the optimisations built into the translator, we ran the \textit{SPEC CPU 2017} suite with various combinations of the available optimisation options.

An overview of the specific behaviour of the mentioned switches can be seen in table~\ref{tab:opt-options}.


% ======= Optimisation comparison results =======
% Results of the intspeed SPEC CPU 2017 runs.
% ================================
\pgfplotstableread[col sep=comma]{benchmarks/spec-compare/base.csv}\basetable
\pgfplotstableread[col sep=comma]{benchmarks/spec-compare/no-ras.csv}\norastable
\pgfplotstableread[col sep=comma]{benchmarks/spec-compare/no-fusion.csv}\nofusiontable
\pgfplotstableread[col sep=comma]{benchmarks/spec-compare/no-jump-no-ras.csv}\nojumpnorastable
\pgfplotstableread[col sep=comma]{benchmarks/spec-compare/no-jump-none.csv}\nonetable

\pgfplotstablecreatecol[create col/copy column from table=\basetable{Est. Base Run Time}]{base}\basetable
\pgfplotstablecreatecol[create col/expr={\thisrow{Est. Base Run Time} / \thisrow{base}}]{ratio}\basetable

\pgfplotstablecreatecol[create col/copy column from table=\basetable{Est. Base Run Time}]{base}\norastable
\pgfplotstablecreatecol[create col/expr={\thisrow{Est. Base Run Time} / \thisrow{base}}]{ratio}\norastable

\pgfplotstablecreatecol[create col/copy column from table=\basetable{Est. Base Run Time}]{base}\nofusiontable
\pgfplotstablecreatecol[create col/expr={\thisrow{Est. Base Run Time} / \thisrow{base}}]{ratio}\nofusiontable

\pgfplotstablecreatecol[create col/copy column from table=\basetable{Est. Base Run Time}]{base}\nojumpnorastable
\pgfplotstablecreatecol[create col/expr={\thisrow{Est. Base Run Time} / \thisrow{base}}]{ratio}\nojumpnorastable

\pgfplotstablecreatecol[create col/copy column from table=\basetable{Est. Base Run Time}]{base}\nonetable
\pgfplotstablecreatecol[create col/expr={\thisrow{Est. Base Run Time} / \thisrow{base}}]{ratio}\nonetable

%Extract xticklabels from file
\makeatletter
\pgfplotsset{
/pgfplots/flexible xticklabels from table/.code n args={2}{%
\pgfplotstablegetcolumn{#2}\of{#1}\to\pgfplots@xticklabels
\renewcommand{\pgfplots@xticklabel}\pgfplots@user@ticklabel@list@x
}
}
\makeatother
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[%
			title = {Optimisation option evaluation},
			ybar,
			area legend,
			ylabel = {Execution time [ratio to base]},
			xtick = data,
			xtick style = {draw = none},
			xticklabel style = {
				inner sep = 0pt,
				anchor = north east,
				rotate = 60
			},
			ytick = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0},
			scaled y ticks = false,
			flexible xticklabels from table={\basetable}{Benchmark},
			ymin = 0, ymax = 6.5,
			ymajorgrids = true,
			bar width = 5pt,
			height = 7.0cm,
			width = 0.9\linewidth,
			legend style = {
				at = {(0.98, 0.97)},
				anchor = north east,
				legend columns = 3,
				column sep = 0.2cm
			}
		]
			% base results
			\addplot+[fill=era-native, draw=black] table [x expr=\coordindex, y=ratio] \basetable;
			
			% no-fusion results
			\addplot+[fill=era-dbt-1, draw=black] table [x expr=\coordindex, y=ratio] \nofusiontable;

			% no-ras results
			\addplot+[fill=era-qemu, draw=black] table [x expr=\coordindex, y=ratio] \norastable;
			
			% no-jump-no-ras results
			\addplot+[fill=era-dbt-1, draw=black] table [x expr=\coordindex, y=ratio] \nojumpnorastable;
			
			% none results
			\addplot+[fill=era-dbt-1, draw=black] table [x expr=\coordindex, y=ratio] \nonetable;

			\legend{Base, \texttt{no-fusion}, \texttt{no-ras}, \texttt{no-jump, no-ras}, \texttt{none}}
		\end{axis}
	\end{tikzpicture}
	\caption[Translator optimisation evaluation results]%
	{Results of \texttt{ref}-workload runs of \textit{SPEC CPU 2017}'s \texttt{intspeed} with various optimisation option combinations (normalised, lower is better).}
	\label{fig:opt-compare}
\end{figure}
% ================================



% todo analysis of SPEC comparisons


\subsection{Data compression via gzip}
% gzip results
Next to the results of the \textit{SPEC CPU 2017} suite, it is also valuable to measure the performance of the translator in real-world workloads by running data compression via \textit{gzip}.

For better comparability, both the native and RISC-V \textit{gzip} binaries were compiled manually with the compiler optimisation level \texttt{-O3} alongside the linker flag \texttt{-static}.
The RISC-V ABI was setup with \texttt{-march=rv64ima} and \texttt{-mabi=lp64}.

% ======= gzip execution time =======
% Execution time of compression (500 MB, 5 runs).
% ===================================
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[%
			title = {Random Data Compression (\textit{gzip}, 500 MB, 5 runs)},
			xbar,
			area legend,
			xlabel = {Execution time [ratio to native] (lower is better)},
			symbolic y coords = {Native,QEMU,DBT,\ldots unoptimised},
			xmin = 0,
			bar shift = 0.0cm,
			y dir = reverse,
			enlarge y limits = {value=0.2, auto},
			xmajorgrids = true,
			height = 5.5cm,
			width = 13.0cm,
			legend style = {
				at = {(0.5, -0.45)},
				anchor = north,
				legend columns = 4,
				column sep = 0.2cm
			}
		]	
			\addplot+ [
				fill=era-native,
				draw=black
			] coordinates {
				(1.0,Native) % 44.15
			};

			\addplot+ [
				fill=era-qemu,
				draw=black
			] coordinates {
				(2.767157418,QEMU) % 122.17
			};
			
			\addplot+ [
				fill=era-dbt-1,
				draw=black
			] coordinates {
				(1.911438279,DBT) % 84.39
			};
			
			\addplot+ [
				fill=era-dbt-2,
				draw=black
			] coordinates {
				(9.527180068,\ldots unoptimised) % 420.625
			};
			
			\legend{Native, QEMU, DBT, DBT unoptimised}
		\end{axis}
	\end{tikzpicture}
	\caption[Execution time of gzip compression]%
	{Execution time of gzip file compression (500 MB of random data, 5 runs) in seconds (normalised, lower is better).\\Unoptimised run executed with \texttt{----optimize=none}.}
	\label{fig:gzip-execution-time}
\end{figure}
% ===================================

Figure~\vref{fig:gzip-execution-time} lists the execution times of \textit{gzip} compressing a pseudo-random $500$ MB file sourced from \texttt{/dev/urandom}\footnote{Reproducible via \texttt{base64 /dev/urandom | head -c 524288000 > random.txt;}}.

Through our very efficient return address stack, recursive jump target translation, macro operation fusion and, most importantly, block chaining we are able to significantly outperform QEMU in random data compression by nearly 45\,\%.
The achieved performance of approximately two times the execution time of a native run is in line with the \textit{SPEC CPU 2017} results shown in figure \ref{fig:spec-results}.

As mentioned in the caption, the unoptimised run was performed with the command line option \texttt{----optimize=none}, which disables all of the optimisation features mentioned above.
The translator will then have to translate every block one-by-one, jump back into the main loop on every block end and fetch the next position based on the current program counter.






















