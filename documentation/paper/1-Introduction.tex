RISC-V is an open ISA first conceptualised in 2010 with the initial goals of research and education in mind.
In contrast to Intels x86~\cite{intel2017man} it employs the RISC (Reduced Instruction Set Computer) scheme providing fewer less powerful Instructions, addressing modes etc in favor of easier to implement micro architectures.
Its development took the lessons learned in terms of backwards compatibility and future-proofing from other widespread ISAs like Intel x86 into account, and aimed to provide an open interface for the architecture, rather than strict implementation details.
This grants a large freedom to the implementors and greatly increases the flexibility and ease of working with the architecture~\cite[S. 1f]{riscvspec}.
As such it looks to be open to future extensions by already defining a basis for future 128-bit integer instructions and instruction length encodings of up to 176 bits (22 Bytes) already defined and the possibility to expand further.


\subsection{Problem description}
There is already some hardware available for RISC-V \footnote{the biggest name here is probably SIFive~\cite{sifive}, which already produce multi-core CPU with super scalar out-of-order pipelines reaching multi GHz clock speeds}, but it is not yet widespread and a lot of developers won't have access to real hardware, so they must rely on emulation to test their code.

\subsubsection{Modes of binary translation}
When attempting to execute guest programs compiled for a foreign architecture on a different native one, there are essentially three distinct approaches at one's disposal.

The main possibilities to achieve this are:
\begin{itemize}
    \item \textbf{Interpretation}, where, much alike interpreted programming languages (e.g.\ JavaScript, Python, or Ruby), the assembly instructions located in the binary are examined while emulating the execution of the program, and equivalent actions are taken on the host system in order to simulate the guest ISA\@.
        \subitem While being probably the easiest to actually be implemented, this comes with a significant performance penalty mainly because every single assembly instruction will have to be interpreted for every execution of that program part, potentially causing a lot of redundant work.
    \item \textbf{Static Binary Translation}, where the guest executable is statically reverse-engineered and translated to the guest architecture as a whole.
    After this translation step, it can be executed as if it were a native binary, without the need for any further special treatment.
    In theory you could reach near native speeds for the generated binary using this technique.
    There some hurdles with this though, one example is register indirect branches, which require some way to convert the guest addresses to native at runtime.
    Any program that produces or edits assembly at runtime would also prove difficult to translate statically.
    \item \textbf{Dynamic Binary Translation} (DBT), which serves as a middle ground between interpreting and statically translating the executable.
    It aims to translate the program on the fly, while only focussing on the parts that are actually needed for execution.
    Therefore it can save some of the overhead of a Static Translator by not worrying about unused code paths and also the other mentioned issues are easily resolved.
    Unlike an Interpreter every instruction only has to be translated once and can then be run without any unnecessary overhead.
    Of course, this assumes that the translation routines are relatively swift in performing their functions, so as not to introduce any more overhead than necessary~\cite[S. 1f.]{bintrans}.
\end{itemize}

\subsubsection{Motivation}
One of the most popular emulators is QEMU~\cite{bellard2005qemu}\@.
While QEMU is a portable DBT that supports a wide variety of guest and host architectures and ISAs, this also makes it hard to optimize it for a specific guest/host combination and therefore the program execution will be slower than necessary.

Our aim is to provide a faster emulator, allowing the execution of RISC-V code on an x86-64 machine by means of dynamic binary translation.

By its very nature, executing code compiled for one architecture on a different one is not an easy task.















