%! Author = simon
%! Date = 22.10.20
In the following, the term \textit{host} will refer to the system of the native architecture the binary translator is built for (in our case, x86-64), and the term \textit{guest} will designate the foreign system we are attempting to emulate (RISC--V).

\subsection{Comparison of the RISC-V and x86-64 ISAs}
\label{sec:isa-cmp}
%todo (mention pseudoinstructions for later)
It is obvious that there are major differences in the two architectures, implied by RISC-V being a reduced instruction set computer (RISC) architecture and x86-64 a complex instruction set computer (CISC) architecture.

The most relevant distinction between RISC-V and x86-64 for the development of this DBT is the different address format and mismatch of general purpose and floating point registers in number.

RISC-V's load-store architecture with a three-operand instruction format allows for a better reuse of data but more instructions due to the explicit load/store operations.

x86-64 however has a register-memory architecture with a two-operand instruction format leading to more implicit/fused memory accesses being used in optimized code.

Also the very nature of translating a RISC architecture into a CISC architecture might seem like it would lead to less instructions.
In praxis the efficient fusion of multiple RISC-V instructions into single x86-64 instructions is difficult considering the fact that we are only presented with the assembly.
Even more a naive implementation leads to an instruction overhead due to the mismatch in supported operands per instruction.

Those challenges will be further elaborated on in section~\ref{sec:Approach}.

\subsection{Environment setup and memory layout}
\label{sec:memory-layout}
As the DBT is responsible for managing the execution environment of the guest binary in the shared address space, it must also handle the setup of said environment.

The header of the ELF-file (\textit{Executable and Linkable Format}) specifies which section(s) of the program need to be loaded, and where in memory they must reside.
The DBT must take care to map the file into memory correctly, while not compromising its own memory region.

Furthermore, the guest registers (see section~\vref{sec:context-switch-reg-handle}) and stack must be initialised in accordance with the architecture specification and calling convention, which necessitates a specific layout of environment and auxiliary parameters as well as command line arguments to be present~\cite[S. 2]{bintrans}.

The stack is set up exactly like the linux kernel would.
As such the stack pointer needs to point at the argument count and then towards higher addresses in order there are the zero terminated argument, environment and auxiliary vector.
Finally some alignment bytes need to be added, so the stack pointer is ABI-conformant 16 Byte aligned.
All of the information is basically just copied from the host in our case.

The memory is laid out as follows:
\begin{table}[h]
	\centering
	\begin{tabular}{rl}
		\toprule
		\textbf{Address range} & \textbf{Usage}\\
		\midrule
		0x780000000000+ & Translator address region\\
		0x77ff81000000+ & JIT generated code\\
		0x77ff807fe000+ & guest stack\\
		(last mapped address + 1)+ & guest heap\\
		defined by ELF file & mapped guest binary\\
		\bottomrule
	\end{tabular}
	\caption[Memory layout]%
	{The layout of the memory space.}
	\label{tab:}
\end{table}

